"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@otplib";
exports.ids = ["vendor-chunks/@otplib"];
exports.modules = {

/***/ "(rsc)/./node_modules/@otplib/core/index.js":
/*!********************************************!*\
  !*** ./node_modules/@otplib/core/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @otplib/core\n *\n * @author Gerald Yeo <contact@fusedthought.com>\n * @version: 12.0.1\n * @license: MIT\n **/ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction objectValues(value) {\n    return Object.keys(value).map((key)=>value[key]);\n}\n(function(HashAlgorithms) {\n    HashAlgorithms[\"SHA1\"] = \"sha1\";\n    HashAlgorithms[\"SHA256\"] = \"sha256\";\n    HashAlgorithms[\"SHA512\"] = \"sha512\";\n})(exports.HashAlgorithms || (exports.HashAlgorithms = {}));\nconst HASH_ALGORITHMS = objectValues(exports.HashAlgorithms);\n(function(KeyEncodings) {\n    KeyEncodings[\"ASCII\"] = \"ascii\";\n    KeyEncodings[\"BASE64\"] = \"base64\";\n    KeyEncodings[\"HEX\"] = \"hex\";\n    KeyEncodings[\"LATIN1\"] = \"latin1\";\n    KeyEncodings[\"UTF8\"] = \"utf8\";\n})(exports.KeyEncodings || (exports.KeyEncodings = {}));\nconst KEY_ENCODINGS = objectValues(exports.KeyEncodings);\n(function(Strategy) {\n    Strategy[\"HOTP\"] = \"hotp\";\n    Strategy[\"TOTP\"] = \"totp\";\n})(exports.Strategy || (exports.Strategy = {}));\nconst STRATEGY = objectValues(exports.Strategy);\nconst createDigestPlaceholder = ()=>{\n    throw new Error(\"Please provide an options.createDigest implementation.\");\n};\nfunction isTokenValid(value) {\n    return /^(\\d+)$/.test(value);\n}\nfunction padStart(value, maxLength, fillString) {\n    if (value.length >= maxLength) {\n        return value;\n    }\n    const padding = Array(maxLength + 1).join(fillString);\n    return `${padding}${value}`.slice(-1 * maxLength);\n}\nfunction keyuri(options) {\n    const tmpl = `otpauth://${options.type}/{labelPrefix}:{accountName}?secret={secret}{query}`;\n    const params = [];\n    if (STRATEGY.indexOf(options.type) < 0) {\n        throw new Error(`Expecting options.type to be one of ${STRATEGY.join(\", \")}. Received ${options.type}.`);\n    }\n    if (options.type === \"hotp\") {\n        if (options.counter == null || typeof options.counter !== \"number\") {\n            throw new Error('Expecting options.counter to be a number when options.type is \"hotp\".');\n        }\n        params.push(`&counter=${options.counter}`);\n    }\n    if (options.type === \"totp\" && options.step) {\n        params.push(`&period=${options.step}`);\n    }\n    if (options.digits) {\n        params.push(`&digits=${options.digits}`);\n    }\n    if (options.algorithm) {\n        params.push(`&algorithm=${options.algorithm.toUpperCase()}`);\n    }\n    if (options.issuer) {\n        params.push(`&issuer=${encodeURIComponent(options.issuer)}`);\n    }\n    return tmpl.replace(\"{labelPrefix}\", encodeURIComponent(options.issuer || options.accountName)).replace(\"{accountName}\", encodeURIComponent(options.accountName)).replace(\"{secret}\", options.secret).replace(\"{query}\", params.join(\"\"));\n}\nclass OTP {\n    constructor(defaultOptions = {}){\n        this._defaultOptions = Object.freeze({\n            ...defaultOptions\n        });\n        this._options = Object.freeze({});\n    }\n    create(defaultOptions = {}) {\n        return new OTP(defaultOptions);\n    }\n    clone(defaultOptions = {}) {\n        const instance = this.create({\n            ...this._defaultOptions,\n            ...defaultOptions\n        });\n        instance.options = this._options;\n        return instance;\n    }\n    get options() {\n        return Object.freeze({\n            ...this._defaultOptions,\n            ...this._options\n        });\n    }\n    set options(options) {\n        this._options = Object.freeze({\n            ...this._options,\n            ...options\n        });\n    }\n    allOptions() {\n        return this.options;\n    }\n    resetOptions() {\n        this._options = Object.freeze({});\n    }\n}\nfunction hotpOptionsValidator(options) {\n    if (typeof options.createDigest !== \"function\") {\n        throw new Error(\"Expecting options.createDigest to be a function.\");\n    }\n    if (typeof options.createHmacKey !== \"function\") {\n        throw new Error(\"Expecting options.createHmacKey to be a function.\");\n    }\n    if (typeof options.digits !== \"number\") {\n        throw new Error(\"Expecting options.digits to be a number.\");\n    }\n    if (!options.algorithm || HASH_ALGORITHMS.indexOf(options.algorithm) < 0) {\n        throw new Error(`Expecting options.algorithm to be one of ${HASH_ALGORITHMS.join(\", \")}. Received ${options.algorithm}.`);\n    }\n    if (!options.encoding || KEY_ENCODINGS.indexOf(options.encoding) < 0) {\n        throw new Error(`Expecting options.encoding to be one of ${KEY_ENCODINGS.join(\", \")}. Received ${options.encoding}.`);\n    }\n}\nconst hotpCreateHmacKey = (algorithm, secret, encoding)=>{\n    return Buffer.from(secret, encoding).toString(\"hex\");\n};\nfunction hotpDefaultOptions() {\n    const options = {\n        algorithm: exports.HashAlgorithms.SHA1,\n        createHmacKey: hotpCreateHmacKey,\n        createDigest: createDigestPlaceholder,\n        digits: 6,\n        encoding: exports.KeyEncodings.ASCII\n    };\n    return options;\n}\nfunction hotpOptions(opt) {\n    const options = {\n        ...hotpDefaultOptions(),\n        ...opt\n    };\n    hotpOptionsValidator(options);\n    return Object.freeze(options);\n}\nfunction hotpCounter(counter) {\n    const hexCounter = counter.toString(16);\n    return padStart(hexCounter, 16, \"0\");\n}\nfunction hotpDigestToToken(hexDigest, digits) {\n    const digest = Buffer.from(hexDigest, \"hex\");\n    const offset = digest[digest.length - 1] & 0xf;\n    const binary = (digest[offset] & 0x7f) << 24 | (digest[offset + 1] & 0xff) << 16 | (digest[offset + 2] & 0xff) << 8 | digest[offset + 3] & 0xff;\n    const token = binary % Math.pow(10, digits);\n    return padStart(String(token), digits, \"0\");\n}\nfunction hotpDigest(secret, counter, options) {\n    const hexCounter = hotpCounter(counter);\n    const hmacKey = options.createHmacKey(options.algorithm, secret, options.encoding);\n    return options.createDigest(options.algorithm, hmacKey, hexCounter);\n}\nfunction hotpToken(secret, counter, options) {\n    const hexDigest = options.digest || hotpDigest(secret, counter, options);\n    return hotpDigestToToken(hexDigest, options.digits);\n}\nfunction hotpCheck(token, secret, counter, options) {\n    if (!isTokenValid(token)) {\n        return false;\n    }\n    const systemToken = hotpToken(secret, counter, options);\n    return token === systemToken;\n}\nfunction hotpKeyuri(accountName, issuer, secret, counter, options) {\n    return keyuri({\n        algorithm: options.algorithm,\n        digits: options.digits,\n        type: exports.Strategy.HOTP,\n        accountName,\n        counter,\n        issuer,\n        secret\n    });\n}\nclass HOTP extends OTP {\n    create(defaultOptions = {}) {\n        return new HOTP(defaultOptions);\n    }\n    allOptions() {\n        return hotpOptions(this.options);\n    }\n    generate(secret, counter) {\n        return hotpToken(secret, counter, this.allOptions());\n    }\n    check(token, secret, counter) {\n        return hotpCheck(token, secret, counter, this.allOptions());\n    }\n    verify(opts) {\n        if (typeof opts !== \"object\") {\n            throw new Error(\"Expecting argument 0 of verify to be an object\");\n        }\n        return this.check(opts.token, opts.secret, opts.counter);\n    }\n    keyuri(accountName, issuer, secret, counter) {\n        return hotpKeyuri(accountName, issuer, secret, counter, this.allOptions());\n    }\n}\nfunction parseWindowBounds(win) {\n    if (typeof win === \"number\") {\n        return [\n            Math.abs(win),\n            Math.abs(win)\n        ];\n    }\n    if (Array.isArray(win)) {\n        const [past, future] = win;\n        if (typeof past === \"number\" && typeof future === \"number\") {\n            return [\n                Math.abs(past),\n                Math.abs(future)\n            ];\n        }\n    }\n    throw new Error(\"Expecting options.window to be an number or [number, number].\");\n}\nfunction totpOptionsValidator(options) {\n    hotpOptionsValidator(options);\n    parseWindowBounds(options.window);\n    if (typeof options.epoch !== \"number\") {\n        throw new Error(\"Expecting options.epoch to be a number.\");\n    }\n    if (typeof options.step !== \"number\") {\n        throw new Error(\"Expecting options.step to be a number.\");\n    }\n}\nconst totpPadSecret = (secret, encoding, minLength)=>{\n    const currentLength = secret.length;\n    const hexSecret = Buffer.from(secret, encoding).toString(\"hex\");\n    if (currentLength < minLength) {\n        const newSecret = new Array(minLength - currentLength + 1).join(hexSecret);\n        return Buffer.from(newSecret, \"hex\").slice(0, minLength).toString(\"hex\");\n    }\n    return hexSecret;\n};\nconst totpCreateHmacKey = (algorithm, secret, encoding)=>{\n    switch(algorithm){\n        case exports.HashAlgorithms.SHA1:\n            return totpPadSecret(secret, encoding, 20);\n        case exports.HashAlgorithms.SHA256:\n            return totpPadSecret(secret, encoding, 32);\n        case exports.HashAlgorithms.SHA512:\n            return totpPadSecret(secret, encoding, 64);\n        default:\n            throw new Error(`Expecting algorithm to be one of ${HASH_ALGORITHMS.join(\", \")}. Received ${algorithm}.`);\n    }\n};\nfunction totpDefaultOptions() {\n    const options = {\n        algorithm: exports.HashAlgorithms.SHA1,\n        createDigest: createDigestPlaceholder,\n        createHmacKey: totpCreateHmacKey,\n        digits: 6,\n        encoding: exports.KeyEncodings.ASCII,\n        epoch: Date.now(),\n        step: 30,\n        window: 0\n    };\n    return options;\n}\nfunction totpOptions(opt) {\n    const options = {\n        ...totpDefaultOptions(),\n        ...opt\n    };\n    totpOptionsValidator(options);\n    return Object.freeze(options);\n}\nfunction totpCounter(epoch, step) {\n    return Math.floor(epoch / step / 1000);\n}\nfunction totpToken(secret, options) {\n    const counter = totpCounter(options.epoch, options.step);\n    return hotpToken(secret, counter, options);\n}\nfunction totpEpochsInWindow(epoch, direction, deltaPerEpoch, numOfEpoches) {\n    const result = [];\n    if (numOfEpoches === 0) {\n        return result;\n    }\n    for(let i = 1; i <= numOfEpoches; i++){\n        const delta = direction * i * deltaPerEpoch;\n        result.push(epoch + delta);\n    }\n    return result;\n}\nfunction totpEpochAvailable(epoch, step, win) {\n    const bounds = parseWindowBounds(win);\n    const delta = step * 1000;\n    return {\n        current: epoch,\n        past: totpEpochsInWindow(epoch, -1, delta, bounds[0]),\n        future: totpEpochsInWindow(epoch, 1, delta, bounds[1])\n    };\n}\nfunction totpCheck(token, secret, options) {\n    if (!isTokenValid(token)) {\n        return false;\n    }\n    const systemToken = totpToken(secret, options);\n    return token === systemToken;\n}\nfunction totpCheckByEpoch(epochs, token, secret, options) {\n    let position = null;\n    epochs.some((epoch, idx)=>{\n        if (totpCheck(token, secret, {\n            ...options,\n            epoch\n        })) {\n            position = idx + 1;\n            return true;\n        }\n        return false;\n    });\n    return position;\n}\nfunction totpCheckWithWindow(token, secret, options) {\n    if (totpCheck(token, secret, options)) {\n        return 0;\n    }\n    const epochs = totpEpochAvailable(options.epoch, options.step, options.window);\n    const backward = totpCheckByEpoch(epochs.past, token, secret, options);\n    if (backward !== null) {\n        return backward * -1;\n    }\n    return totpCheckByEpoch(epochs.future, token, secret, options);\n}\nfunction totpTimeUsed(epoch, step) {\n    return Math.floor(epoch / 1000) % step;\n}\nfunction totpTimeRemaining(epoch, step) {\n    return step - totpTimeUsed(epoch, step);\n}\nfunction totpKeyuri(accountName, issuer, secret, options) {\n    return keyuri({\n        algorithm: options.algorithm,\n        digits: options.digits,\n        step: options.step,\n        type: exports.Strategy.TOTP,\n        accountName,\n        issuer,\n        secret\n    });\n}\nclass TOTP extends HOTP {\n    create(defaultOptions = {}) {\n        return new TOTP(defaultOptions);\n    }\n    allOptions() {\n        return totpOptions(this.options);\n    }\n    generate(secret) {\n        return totpToken(secret, this.allOptions());\n    }\n    checkDelta(token, secret) {\n        return totpCheckWithWindow(token, secret, this.allOptions());\n    }\n    check(token, secret) {\n        const delta = this.checkDelta(token, secret);\n        return typeof delta === \"number\";\n    }\n    verify(opts) {\n        if (typeof opts !== \"object\") {\n            throw new Error(\"Expecting argument 0 of verify to be an object\");\n        }\n        return this.check(opts.token, opts.secret);\n    }\n    timeRemaining() {\n        const options = this.allOptions();\n        return totpTimeRemaining(options.epoch, options.step);\n    }\n    timeUsed() {\n        const options = this.allOptions();\n        return totpTimeUsed(options.epoch, options.step);\n    }\n    keyuri(accountName, issuer, secret) {\n        return totpKeyuri(accountName, issuer, secret, this.allOptions());\n    }\n}\nfunction authenticatorOptionValidator(options) {\n    totpOptionsValidator(options);\n    if (typeof options.keyDecoder !== \"function\") {\n        throw new Error(\"Expecting options.keyDecoder to be a function.\");\n    }\n    if (options.keyEncoder && typeof options.keyEncoder !== \"function\") {\n        throw new Error(\"Expecting options.keyEncoder to be a function.\");\n    }\n}\nfunction authenticatorDefaultOptions() {\n    const options = {\n        algorithm: exports.HashAlgorithms.SHA1,\n        createDigest: createDigestPlaceholder,\n        createHmacKey: totpCreateHmacKey,\n        digits: 6,\n        encoding: exports.KeyEncodings.HEX,\n        epoch: Date.now(),\n        step: 30,\n        window: 0\n    };\n    return options;\n}\nfunction authenticatorOptions(opt) {\n    const options = {\n        ...authenticatorDefaultOptions(),\n        ...opt\n    };\n    authenticatorOptionValidator(options);\n    return Object.freeze(options);\n}\nfunction authenticatorEncoder(secret, options) {\n    return options.keyEncoder(secret, options.encoding);\n}\nfunction authenticatorDecoder(secret, options) {\n    return options.keyDecoder(secret, options.encoding);\n}\nfunction authenticatorGenerateSecret(numberOfBytes, options) {\n    const key = options.createRandomBytes(numberOfBytes, options.encoding);\n    return authenticatorEncoder(key, options);\n}\nfunction authenticatorToken(secret, options) {\n    return totpToken(authenticatorDecoder(secret, options), options);\n}\nfunction authenticatorCheckWithWindow(token, secret, options) {\n    return totpCheckWithWindow(token, authenticatorDecoder(secret, options), options);\n}\nclass Authenticator extends TOTP {\n    create(defaultOptions = {}) {\n        return new Authenticator(defaultOptions);\n    }\n    allOptions() {\n        return authenticatorOptions(this.options);\n    }\n    generate(secret) {\n        return authenticatorToken(secret, this.allOptions());\n    }\n    checkDelta(token, secret) {\n        return authenticatorCheckWithWindow(token, secret, this.allOptions());\n    }\n    encode(secret) {\n        return authenticatorEncoder(secret, this.allOptions());\n    }\n    decode(secret) {\n        return authenticatorDecoder(secret, this.allOptions());\n    }\n    generateSecret(numberOfBytes = 10) {\n        return authenticatorGenerateSecret(numberOfBytes, this.allOptions());\n    }\n}\nexports.Authenticator = Authenticator;\nexports.HASH_ALGORITHMS = HASH_ALGORITHMS;\nexports.HOTP = HOTP;\nexports.KEY_ENCODINGS = KEY_ENCODINGS;\nexports.OTP = OTP;\nexports.STRATEGY = STRATEGY;\nexports.TOTP = TOTP;\nexports.authenticatorCheckWithWindow = authenticatorCheckWithWindow;\nexports.authenticatorDecoder = authenticatorDecoder;\nexports.authenticatorDefaultOptions = authenticatorDefaultOptions;\nexports.authenticatorEncoder = authenticatorEncoder;\nexports.authenticatorGenerateSecret = authenticatorGenerateSecret;\nexports.authenticatorOptionValidator = authenticatorOptionValidator;\nexports.authenticatorOptions = authenticatorOptions;\nexports.authenticatorToken = authenticatorToken;\nexports.createDigestPlaceholder = createDigestPlaceholder;\nexports.hotpCheck = hotpCheck;\nexports.hotpCounter = hotpCounter;\nexports.hotpCreateHmacKey = hotpCreateHmacKey;\nexports.hotpDefaultOptions = hotpDefaultOptions;\nexports.hotpDigestToToken = hotpDigestToToken;\nexports.hotpKeyuri = hotpKeyuri;\nexports.hotpOptions = hotpOptions;\nexports.hotpOptionsValidator = hotpOptionsValidator;\nexports.hotpToken = hotpToken;\nexports.isTokenValid = isTokenValid;\nexports.keyuri = keyuri;\nexports.objectValues = objectValues;\nexports.padStart = padStart;\nexports.totpCheck = totpCheck;\nexports.totpCheckByEpoch = totpCheckByEpoch;\nexports.totpCheckWithWindow = totpCheckWithWindow;\nexports.totpCounter = totpCounter;\nexports.totpCreateHmacKey = totpCreateHmacKey;\nexports.totpDefaultOptions = totpDefaultOptions;\nexports.totpEpochAvailable = totpEpochAvailable;\nexports.totpKeyuri = totpKeyuri;\nexports.totpOptions = totpOptions;\nexports.totpOptionsValidator = totpOptionsValidator;\nexports.totpPadSecret = totpPadSecret;\nexports.totpTimeRemaining = totpTimeRemaining;\nexports.totpTimeUsed = totpTimeUsed;\nexports.totpToken = totpToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG90cGxpYi9jb3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7RUFNRSxHQUNGO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELFNBQVNDLGFBQWFELEtBQUs7SUFDekIsT0FBT0gsT0FBT0ssSUFBSSxDQUFDRixPQUFPRyxHQUFHLENBQUNDLENBQUFBLE1BQU9KLEtBQUssQ0FBQ0ksSUFBSTtBQUNqRDtBQUNDLFVBQVVDLGNBQWM7SUFDdkJBLGNBQWMsQ0FBQyxPQUFPLEdBQUc7SUFDekJBLGNBQWMsQ0FBQyxTQUFTLEdBQUc7SUFDM0JBLGNBQWMsQ0FBQyxTQUFTLEdBQUc7QUFDN0IsR0FBR04sUUFBUU0sY0FBYyxJQUFLTixDQUFBQSxzQkFBc0IsR0FBRyxDQUFDO0FBQ3hELE1BQU1PLGtCQUFrQkwsYUFBYUYsUUFBUU0sY0FBYztBQUMxRCxVQUFVRSxZQUFZO0lBQ3JCQSxZQUFZLENBQUMsUUFBUSxHQUFHO0lBQ3hCQSxZQUFZLENBQUMsU0FBUyxHQUFHO0lBQ3pCQSxZQUFZLENBQUMsTUFBTSxHQUFHO0lBQ3RCQSxZQUFZLENBQUMsU0FBUyxHQUFHO0lBQ3pCQSxZQUFZLENBQUMsT0FBTyxHQUFHO0FBQ3pCLEdBQUdSLFFBQVFRLFlBQVksSUFBS1IsQ0FBQUEsb0JBQW9CLEdBQUcsQ0FBQztBQUNwRCxNQUFNUyxnQkFBZ0JQLGFBQWFGLFFBQVFRLFlBQVk7QUFDdEQsVUFBVUUsUUFBUTtJQUNqQkEsUUFBUSxDQUFDLE9BQU8sR0FBRztJQUNuQkEsUUFBUSxDQUFDLE9BQU8sR0FBRztBQUNyQixHQUFHVixRQUFRVSxRQUFRLElBQUtWLENBQUFBLGdCQUFnQixHQUFHLENBQUM7QUFDNUMsTUFBTVcsV0FBV1QsYUFBYUYsUUFBUVUsUUFBUTtBQUM5QyxNQUFNRSwwQkFBMEI7SUFDOUIsTUFBTSxJQUFJQyxNQUFNO0FBQ2xCO0FBQ0EsU0FBU0MsYUFBYWIsS0FBSztJQUN6QixP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cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9Ab3RwbGliL2NvcmUvaW5kZXguanM/MTViZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBvdHBsaWIvY29yZVxuICpcbiAqIEBhdXRob3IgR2VyYWxkIFllbyA8Y29udGFjdEBmdXNlZHRob3VnaHQuY29tPlxuICogQHZlcnNpb246IDEyLjAuMVxuICogQGxpY2Vuc2U6IE1JVFxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBvYmplY3RWYWx1ZXModmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoa2V5ID0+IHZhbHVlW2tleV0pO1xufVxuKGZ1bmN0aW9uIChIYXNoQWxnb3JpdGhtcykge1xuICBIYXNoQWxnb3JpdGhtc1tcIlNIQTFcIl0gPSBcInNoYTFcIjtcbiAgSGFzaEFsZ29yaXRobXNbXCJTSEEyNTZcIl0gPSBcInNoYTI1NlwiO1xuICBIYXNoQWxnb3JpdGhtc1tcIlNIQTUxMlwiXSA9IFwic2hhNTEyXCI7XG59KShleHBvcnRzLkhhc2hBbGdvcml0aG1zIHx8IChleHBvcnRzLkhhc2hBbGdvcml0aG1zID0ge30pKTtcbmNvbnN0IEhBU0hfQUxHT1JJVEhNUyA9IG9iamVjdFZhbHVlcyhleHBvcnRzLkhhc2hBbGdvcml0aG1zKTtcbihmdW5jdGlvbiAoS2V5RW5jb2RpbmdzKSB7XG4gIEtleUVuY29kaW5nc1tcIkFTQ0lJXCJdID0gXCJhc2NpaVwiO1xuICBLZXlFbmNvZGluZ3NbXCJCQVNFNjRcIl0gPSBcImJhc2U2NFwiO1xuICBLZXlFbmNvZGluZ3NbXCJIRVhcIl0gPSBcImhleFwiO1xuICBLZXlFbmNvZGluZ3NbXCJMQVRJTjFcIl0gPSBcImxhdGluMVwiO1xuICBLZXlFbmNvZGluZ3NbXCJVVEY4XCJdID0gXCJ1dGY4XCI7XG59KShleHBvcnRzLktleUVuY29kaW5ncyB8fCAoZXhwb3J0cy5LZXlFbmNvZGluZ3MgPSB7fSkpO1xuY29uc3QgS0VZX0VOQ09ESU5HUyA9IG9iamVjdFZhbHVlcyhleHBvcnRzLktleUVuY29kaW5ncyk7XG4oZnVuY3Rpb24gKFN0cmF0ZWd5KSB7XG4gIFN0cmF0ZWd5W1wiSE9UUFwiXSA9IFwiaG90cFwiO1xuICBTdHJhdGVneVtcIlRPVFBcIl0gPSBcInRvdHBcIjtcbn0pKGV4cG9ydHMuU3RyYXRlZ3kgfHwgKGV4cG9ydHMuU3RyYXRlZ3kgPSB7fSkpO1xuY29uc3QgU1RSQVRFR1kgPSBvYmplY3RWYWx1ZXMoZXhwb3J0cy5TdHJhdGVneSk7XG5jb25zdCBjcmVhdGVEaWdlc3RQbGFjZWhvbGRlciA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhbiBvcHRpb25zLmNyZWF0ZURpZ2VzdCBpbXBsZW1lbnRhdGlvbi4nKTtcbn07XG5mdW5jdGlvbiBpc1Rva2VuVmFsaWQodmFsdWUpIHtcbiAgcmV0dXJuIC9eKFxcZCspJC8udGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwYWRTdGFydCh2YWx1ZSwgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nKSB7XG4gIGlmICh2YWx1ZS5sZW5ndGggPj0gbWF4TGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbnN0IHBhZGRpbmcgPSBBcnJheShtYXhMZW5ndGggKyAxKS5qb2luKGZpbGxTdHJpbmcpO1xuICByZXR1cm4gYCR7cGFkZGluZ30ke3ZhbHVlfWAuc2xpY2UoLTEgKiBtYXhMZW5ndGgpO1xufVxuZnVuY3Rpb24ga2V5dXJpKG9wdGlvbnMpIHtcbiAgY29uc3QgdG1wbCA9IGBvdHBhdXRoOi8vJHtvcHRpb25zLnR5cGV9L3tsYWJlbFByZWZpeH06e2FjY291bnROYW1lfT9zZWNyZXQ9e3NlY3JldH17cXVlcnl9YDtcbiAgY29uc3QgcGFyYW1zID0gW107XG4gIGlmIChTVFJBVEVHWS5pbmRleE9mKG9wdGlvbnMudHlwZSkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3Rpbmcgb3B0aW9ucy50eXBlIHRvIGJlIG9uZSBvZiAke1NUUkFURUdZLmpvaW4oJywgJyl9LiBSZWNlaXZlZCAke29wdGlvbnMudHlwZX0uYCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2hvdHAnKSB7XG4gICAgaWYgKG9wdGlvbnMuY291bnRlciA9PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zLmNvdW50ZXIgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyBvcHRpb25zLmNvdW50ZXIgdG8gYmUgYSBudW1iZXIgd2hlbiBvcHRpb25zLnR5cGUgaXMgXCJob3RwXCIuJyk7XG4gICAgfVxuICAgIHBhcmFtcy5wdXNoKGAmY291bnRlcj0ke29wdGlvbnMuY291bnRlcn1gKTtcbiAgfVxuICBpZiAob3B0aW9ucy50eXBlID09PSAndG90cCcgJiYgb3B0aW9ucy5zdGVwKSB7XG4gICAgcGFyYW1zLnB1c2goYCZwZXJpb2Q9JHtvcHRpb25zLnN0ZXB9YCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZGlnaXRzKSB7XG4gICAgcGFyYW1zLnB1c2goYCZkaWdpdHM9JHtvcHRpb25zLmRpZ2l0c31gKTtcbiAgfVxuICBpZiAob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgICBwYXJhbXMucHVzaChgJmFsZ29yaXRobT0ke29wdGlvbnMuYWxnb3JpdGhtLnRvVXBwZXJDYXNlKCl9YCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuaXNzdWVyKSB7XG4gICAgcGFyYW1zLnB1c2goYCZpc3N1ZXI9JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5pc3N1ZXIpfWApO1xuICB9XG4gIHJldHVybiB0bXBsLnJlcGxhY2UoJ3tsYWJlbFByZWZpeH0nLCBlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5pc3N1ZXIgfHwgb3B0aW9ucy5hY2NvdW50TmFtZSkpLnJlcGxhY2UoJ3thY2NvdW50TmFtZX0nLCBlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5hY2NvdW50TmFtZSkpLnJlcGxhY2UoJ3tzZWNyZXR9Jywgb3B0aW9ucy5zZWNyZXQpLnJlcGxhY2UoJ3txdWVyeX0nLCBwYXJhbXMuam9pbignJykpO1xufVxuY2xhc3MgT1RQIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdE9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7IC4uLmRlZmF1bHRPcHRpb25zXG4gICAgfSk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5mcmVlemUoe30pO1xuICB9XG4gIGNyZWF0ZShkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBPVFAoZGVmYXVsdE9wdGlvbnMpO1xuICB9XG4gIGNsb25lKGRlZmF1bHRPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuY3JlYXRlKHsgLi4udGhpcy5fZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5kZWZhdWx0T3B0aW9uc1xuICAgIH0pO1xuICAgIGluc3RhbmNlLm9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLnRoaXMuX2RlZmF1bHRPcHRpb25zLFxuICAgICAgLi4udGhpcy5fb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7IC4uLnRoaXMuX29wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgYWxsT3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICB9XG4gIHJlc2V0T3B0aW9ucygpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaG90cE9wdGlvbnNWYWxpZGF0b3Iob3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMuY3JlYXRlRGlnZXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3Rpbmcgb3B0aW9ucy5jcmVhdGVEaWdlc3QgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuY3JlYXRlSG1hY0tleSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIG9wdGlvbnMuY3JlYXRlSG1hY0tleSB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5kaWdpdHMgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3Rpbmcgb3B0aW9ucy5kaWdpdHMgdG8gYmUgYSBudW1iZXIuJyk7XG4gIH1cbiAgaWYgKCFvcHRpb25zLmFsZ29yaXRobSB8fCBIQVNIX0FMR09SSVRITVMuaW5kZXhPZihvcHRpb25zLmFsZ29yaXRobSkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3Rpbmcgb3B0aW9ucy5hbGdvcml0aG0gdG8gYmUgb25lIG9mICR7SEFTSF9BTEdPUklUSE1TLmpvaW4oJywgJyl9LiBSZWNlaXZlZCAke29wdGlvbnMuYWxnb3JpdGhtfS5gKTtcbiAgfVxuICBpZiAoIW9wdGlvbnMuZW5jb2RpbmcgfHwgS0VZX0VOQ09ESU5HUy5pbmRleE9mKG9wdGlvbnMuZW5jb2RpbmcpIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0aW5nIG9wdGlvbnMuZW5jb2RpbmcgdG8gYmUgb25lIG9mICR7S0VZX0VOQ09ESU5HUy5qb2luKCcsICcpfS4gUmVjZWl2ZWQgJHtvcHRpb25zLmVuY29kaW5nfS5gKTtcbiAgfVxufVxuY29uc3QgaG90cENyZWF0ZUhtYWNLZXkgPSAoYWxnb3JpdGhtLCBzZWNyZXQsIGVuY29kaW5nKSA9PiB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNyZXQsIGVuY29kaW5nKS50b1N0cmluZygnaGV4Jyk7XG59O1xuZnVuY3Rpb24gaG90cERlZmF1bHRPcHRpb25zKCkge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGFsZ29yaXRobTogZXhwb3J0cy5IYXNoQWxnb3JpdGhtcy5TSEExLFxuICAgIGNyZWF0ZUhtYWNLZXk6IGhvdHBDcmVhdGVIbWFjS2V5LFxuICAgIGNyZWF0ZURpZ2VzdDogY3JlYXRlRGlnZXN0UGxhY2Vob2xkZXIsXG4gICAgZGlnaXRzOiA2LFxuICAgIGVuY29kaW5nOiBleHBvcnRzLktleUVuY29kaW5ncy5BU0NJSVxuICB9O1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGhvdHBPcHRpb25zKG9wdCkge1xuICBjb25zdCBvcHRpb25zID0geyAuLi5ob3RwRGVmYXVsdE9wdGlvbnMoKSxcbiAgICAuLi5vcHRcbiAgfTtcbiAgaG90cE9wdGlvbnNWYWxpZGF0b3Iob3B0aW9ucyk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaG90cENvdW50ZXIoY291bnRlcikge1xuICBjb25zdCBoZXhDb3VudGVyID0gY291bnRlci50b1N0cmluZygxNik7XG4gIHJldHVybiBwYWRTdGFydChoZXhDb3VudGVyLCAxNiwgJzAnKTtcbn1cbmZ1bmN0aW9uIGhvdHBEaWdlc3RUb1Rva2VuKGhleERpZ2VzdCwgZGlnaXRzKSB7XG4gIGNvbnN0IGRpZ2VzdCA9IEJ1ZmZlci5mcm9tKGhleERpZ2VzdCwgJ2hleCcpO1xuICBjb25zdCBvZmZzZXQgPSBkaWdlc3RbZGlnZXN0Lmxlbmd0aCAtIDFdICYgMHhmO1xuICBjb25zdCBiaW5hcnkgPSAoZGlnZXN0W29mZnNldF0gJiAweDdmKSA8PCAyNCB8IChkaWdlc3Rbb2Zmc2V0ICsgMV0gJiAweGZmKSA8PCAxNiB8IChkaWdlc3Rbb2Zmc2V0ICsgMl0gJiAweGZmKSA8PCA4IHwgZGlnZXN0W29mZnNldCArIDNdICYgMHhmZjtcbiAgY29uc3QgdG9rZW4gPSBiaW5hcnkgJSBNYXRoLnBvdygxMCwgZGlnaXRzKTtcbiAgcmV0dXJuIHBhZFN0YXJ0KFN0cmluZyh0b2tlbiksIGRpZ2l0cywgJzAnKTtcbn1cbmZ1bmN0aW9uIGhvdHBEaWdlc3Qoc2VjcmV0LCBjb3VudGVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGhleENvdW50ZXIgPSBob3RwQ291bnRlcihjb3VudGVyKTtcbiAgY29uc3QgaG1hY0tleSA9IG9wdGlvbnMuY3JlYXRlSG1hY0tleShvcHRpb25zLmFsZ29yaXRobSwgc2VjcmV0LCBvcHRpb25zLmVuY29kaW5nKTtcbiAgcmV0dXJuIG9wdGlvbnMuY3JlYXRlRGlnZXN0KG9wdGlvbnMuYWxnb3JpdGhtLCBobWFjS2V5LCBoZXhDb3VudGVyKTtcbn1cbmZ1bmN0aW9uIGhvdHBUb2tlbihzZWNyZXQsIGNvdW50ZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgaGV4RGlnZXN0ID0gb3B0aW9ucy5kaWdlc3QgfHwgaG90cERpZ2VzdChzZWNyZXQsIGNvdW50ZXIsIG9wdGlvbnMpO1xuICByZXR1cm4gaG90cERpZ2VzdFRvVG9rZW4oaGV4RGlnZXN0LCBvcHRpb25zLmRpZ2l0cyk7XG59XG5mdW5jdGlvbiBob3RwQ2hlY2sodG9rZW4sIHNlY3JldCwgY291bnRlciwgb3B0aW9ucykge1xuICBpZiAoIWlzVG9rZW5WYWxpZCh0b2tlbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3lzdGVtVG9rZW4gPSBob3RwVG9rZW4oc2VjcmV0LCBjb3VudGVyLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRva2VuID09PSBzeXN0ZW1Ub2tlbjtcbn1cbmZ1bmN0aW9uIGhvdHBLZXl1cmkoYWNjb3VudE5hbWUsIGlzc3Vlciwgc2VjcmV0LCBjb3VudGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBrZXl1cmkoe1xuICAgIGFsZ29yaXRobTogb3B0aW9ucy5hbGdvcml0aG0sXG4gICAgZGlnaXRzOiBvcHRpb25zLmRpZ2l0cyxcbiAgICB0eXBlOiBleHBvcnRzLlN0cmF0ZWd5LkhPVFAsXG4gICAgYWNjb3VudE5hbWUsXG4gICAgY291bnRlcixcbiAgICBpc3N1ZXIsXG4gICAgc2VjcmV0XG4gIH0pO1xufVxuY2xhc3MgSE9UUCBleHRlbmRzIE9UUCB7XG4gIGNyZWF0ZShkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBIT1RQKGRlZmF1bHRPcHRpb25zKTtcbiAgfVxuICBhbGxPcHRpb25zKCkge1xuICAgIHJldHVybiBob3RwT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICB9XG4gIGdlbmVyYXRlKHNlY3JldCwgY291bnRlcikge1xuICAgIHJldHVybiBob3RwVG9rZW4oc2VjcmV0LCBjb3VudGVyLCB0aGlzLmFsbE9wdGlvbnMoKSk7XG4gIH1cbiAgY2hlY2sodG9rZW4sIHNlY3JldCwgY291bnRlcikge1xuICAgIHJldHVybiBob3RwQ2hlY2sodG9rZW4sIHNlY3JldCwgY291bnRlciwgdGhpcy5hbGxPcHRpb25zKCkpO1xuICB9XG4gIHZlcmlmeShvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RpbmcgYXJndW1lbnQgMCBvZiB2ZXJpZnkgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNoZWNrKG9wdHMudG9rZW4sIG9wdHMuc2VjcmV0LCBvcHRzLmNvdW50ZXIpO1xuICB9XG4gIGtleXVyaShhY2NvdW50TmFtZSwgaXNzdWVyLCBzZWNyZXQsIGNvdW50ZXIpIHtcbiAgICByZXR1cm4gaG90cEtleXVyaShhY2NvdW50TmFtZSwgaXNzdWVyLCBzZWNyZXQsIGNvdW50ZXIsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVdpbmRvd0JvdW5kcyh3aW4pIHtcbiAgaWYgKHR5cGVvZiB3aW4gPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIFtNYXRoLmFicyh3aW4pLCBNYXRoLmFicyh3aW4pXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh3aW4pKSB7XG4gICAgY29uc3QgW3Bhc3QsIGZ1dHVyZV0gPSB3aW47XG4gICAgaWYgKHR5cGVvZiBwYXN0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZnV0dXJlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIFtNYXRoLmFicyhwYXN0KSwgTWF0aC5hYnMoZnV0dXJlKV07XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIG9wdGlvbnMud2luZG93IHRvIGJlIGFuIG51bWJlciBvciBbbnVtYmVyLCBudW1iZXJdLicpO1xufVxuZnVuY3Rpb24gdG90cE9wdGlvbnNWYWxpZGF0b3Iob3B0aW9ucykge1xuICBob3RwT3B0aW9uc1ZhbGlkYXRvcihvcHRpb25zKTtcbiAgcGFyc2VXaW5kb3dCb3VuZHMob3B0aW9ucy53aW5kb3cpO1xuICBpZiAodHlwZW9mIG9wdGlvbnMuZXBvY2ggIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3Rpbmcgb3B0aW9ucy5lcG9jaCB0byBiZSBhIG51bWJlci4nKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuc3RlcCAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyBvcHRpb25zLnN0ZXAgdG8gYmUgYSBudW1iZXIuJyk7XG4gIH1cbn1cbmNvbnN0IHRvdHBQYWRTZWNyZXQgPSAoc2VjcmV0LCBlbmNvZGluZywgbWluTGVuZ3RoKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRMZW5ndGggPSBzZWNyZXQubGVuZ3RoO1xuICBjb25zdCBoZXhTZWNyZXQgPSBCdWZmZXIuZnJvbShzZWNyZXQsIGVuY29kaW5nKS50b1N0cmluZygnaGV4Jyk7XG4gIGlmIChjdXJyZW50TGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgY29uc3QgbmV3U2VjcmV0ID0gbmV3IEFycmF5KG1pbkxlbmd0aCAtIGN1cnJlbnRMZW5ndGggKyAxKS5qb2luKGhleFNlY3JldCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ld1NlY3JldCwgJ2hleCcpLnNsaWNlKDAsIG1pbkxlbmd0aCkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG4gIHJldHVybiBoZXhTZWNyZXQ7XG59O1xuY29uc3QgdG90cENyZWF0ZUhtYWNLZXkgPSAoYWxnb3JpdGhtLCBzZWNyZXQsIGVuY29kaW5nKSA9PiB7XG4gIHN3aXRjaCAoYWxnb3JpdGhtKSB7XG4gICAgY2FzZSBleHBvcnRzLkhhc2hBbGdvcml0aG1zLlNIQTE6XG4gICAgICByZXR1cm4gdG90cFBhZFNlY3JldChzZWNyZXQsIGVuY29kaW5nLCAyMCk7XG4gICAgY2FzZSBleHBvcnRzLkhhc2hBbGdvcml0aG1zLlNIQTI1NjpcbiAgICAgIHJldHVybiB0b3RwUGFkU2VjcmV0KHNlY3JldCwgZW5jb2RpbmcsIDMyKTtcbiAgICBjYXNlIGV4cG9ydHMuSGFzaEFsZ29yaXRobXMuU0hBNTEyOlxuICAgICAgcmV0dXJuIHRvdHBQYWRTZWNyZXQoc2VjcmV0LCBlbmNvZGluZywgNjQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGluZyBhbGdvcml0aG0gdG8gYmUgb25lIG9mICR7SEFTSF9BTEdPUklUSE1TLmpvaW4oJywgJyl9LiBSZWNlaXZlZCAke2FsZ29yaXRobX0uYCk7XG4gIH1cbn07XG5mdW5jdGlvbiB0b3RwRGVmYXVsdE9wdGlvbnMoKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgYWxnb3JpdGhtOiBleHBvcnRzLkhhc2hBbGdvcml0aG1zLlNIQTEsXG4gICAgY3JlYXRlRGlnZXN0OiBjcmVhdGVEaWdlc3RQbGFjZWhvbGRlcixcbiAgICBjcmVhdGVIbWFjS2V5OiB0b3RwQ3JlYXRlSG1hY0tleSxcbiAgICBkaWdpdHM6IDYsXG4gICAgZW5jb2Rpbmc6IGV4cG9ydHMuS2V5RW5jb2RpbmdzLkFTQ0lJLFxuICAgIGVwb2NoOiBEYXRlLm5vdygpLFxuICAgIHN0ZXA6IDMwLFxuICAgIHdpbmRvdzogMFxuICB9O1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIHRvdHBPcHRpb25zKG9wdCkge1xuICBjb25zdCBvcHRpb25zID0geyAuLi50b3RwRGVmYXVsdE9wdGlvbnMoKSxcbiAgICAuLi5vcHRcbiAgfTtcbiAgdG90cE9wdGlvbnNWYWxpZGF0b3Iob3B0aW9ucyk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdG90cENvdW50ZXIoZXBvY2gsIHN0ZXApIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZXBvY2ggLyBzdGVwIC8gMTAwMCk7XG59XG5mdW5jdGlvbiB0b3RwVG9rZW4oc2VjcmV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvdW50ZXIgPSB0b3RwQ291bnRlcihvcHRpb25zLmVwb2NoLCBvcHRpb25zLnN0ZXApO1xuICByZXR1cm4gaG90cFRva2VuKHNlY3JldCwgY291bnRlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB0b3RwRXBvY2hzSW5XaW5kb3coZXBvY2gsIGRpcmVjdGlvbiwgZGVsdGFQZXJFcG9jaCwgbnVtT2ZFcG9jaGVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpZiAobnVtT2ZFcG9jaGVzID09PSAwKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBudW1PZkVwb2NoZXM7IGkrKykge1xuICAgIGNvbnN0IGRlbHRhID0gZGlyZWN0aW9uICogaSAqIGRlbHRhUGVyRXBvY2g7XG4gICAgcmVzdWx0LnB1c2goZXBvY2ggKyBkZWx0YSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvdHBFcG9jaEF2YWlsYWJsZShlcG9jaCwgc3RlcCwgd2luKSB7XG4gIGNvbnN0IGJvdW5kcyA9IHBhcnNlV2luZG93Qm91bmRzKHdpbik7XG4gIGNvbnN0IGRlbHRhID0gc3RlcCAqIDEwMDA7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogZXBvY2gsXG4gICAgcGFzdDogdG90cEVwb2Noc0luV2luZG93KGVwb2NoLCAtMSwgZGVsdGEsIGJvdW5kc1swXSksXG4gICAgZnV0dXJlOiB0b3RwRXBvY2hzSW5XaW5kb3coZXBvY2gsIDEsIGRlbHRhLCBib3VuZHNbMV0pXG4gIH07XG59XG5mdW5jdGlvbiB0b3RwQ2hlY2sodG9rZW4sIHNlY3JldCwgb3B0aW9ucykge1xuICBpZiAoIWlzVG9rZW5WYWxpZCh0b2tlbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3lzdGVtVG9rZW4gPSB0b3RwVG9rZW4oc2VjcmV0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRva2VuID09PSBzeXN0ZW1Ub2tlbjtcbn1cbmZ1bmN0aW9uIHRvdHBDaGVja0J5RXBvY2goZXBvY2hzLCB0b2tlbiwgc2VjcmV0LCBvcHRpb25zKSB7XG4gIGxldCBwb3NpdGlvbiA9IG51bGw7XG4gIGVwb2Nocy5zb21lKChlcG9jaCwgaWR4KSA9PiB7XG4gICAgaWYgKHRvdHBDaGVjayh0b2tlbiwgc2VjcmV0LCB7IC4uLm9wdGlvbnMsXG4gICAgICBlcG9jaFxuICAgIH0pKSB7XG4gICAgICBwb3NpdGlvbiA9IGlkeCArIDE7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuZnVuY3Rpb24gdG90cENoZWNrV2l0aFdpbmRvdyh0b2tlbiwgc2VjcmV0LCBvcHRpb25zKSB7XG4gIGlmICh0b3RwQ2hlY2sodG9rZW4sIHNlY3JldCwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBlcG9jaHMgPSB0b3RwRXBvY2hBdmFpbGFibGUob3B0aW9ucy5lcG9jaCwgb3B0aW9ucy5zdGVwLCBvcHRpb25zLndpbmRvdyk7XG4gIGNvbnN0IGJhY2t3YXJkID0gdG90cENoZWNrQnlFcG9jaChlcG9jaHMucGFzdCwgdG9rZW4sIHNlY3JldCwgb3B0aW9ucyk7XG4gIGlmIChiYWNrd2FyZCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBiYWNrd2FyZCAqIC0xO1xuICB9XG4gIHJldHVybiB0b3RwQ2hlY2tCeUVwb2NoKGVwb2Nocy5mdXR1cmUsIHRva2VuLCBzZWNyZXQsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdG90cFRpbWVVc2VkKGVwb2NoLCBzdGVwKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGVwb2NoIC8gMTAwMCkgJSBzdGVwO1xufVxuZnVuY3Rpb24gdG90cFRpbWVSZW1haW5pbmcoZXBvY2gsIHN0ZXApIHtcbiAgcmV0dXJuIHN0ZXAgLSB0b3RwVGltZVVzZWQoZXBvY2gsIHN0ZXApO1xufVxuZnVuY3Rpb24gdG90cEtleXVyaShhY2NvdW50TmFtZSwgaXNzdWVyLCBzZWNyZXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGtleXVyaSh7XG4gICAgYWxnb3JpdGhtOiBvcHRpb25zLmFsZ29yaXRobSxcbiAgICBkaWdpdHM6IG9wdGlvbnMuZGlnaXRzLFxuICAgIHN0ZXA6IG9wdGlvbnMuc3RlcCxcbiAgICB0eXBlOiBleHBvcnRzLlN0cmF0ZWd5LlRPVFAsXG4gICAgYWNjb3VudE5hbWUsXG4gICAgaXNzdWVyLFxuICAgIHNlY3JldFxuICB9KTtcbn1cbmNsYXNzIFRPVFAgZXh0ZW5kcyBIT1RQIHtcbiAgY3JlYXRlKGRlZmF1bHRPcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFRPVFAoZGVmYXVsdE9wdGlvbnMpO1xuICB9XG4gIGFsbE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRvdHBPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gIH1cbiAgZ2VuZXJhdGUoc2VjcmV0KSB7XG4gICAgcmV0dXJuIHRvdHBUb2tlbihzZWNyZXQsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxuICBjaGVja0RlbHRhKHRva2VuLCBzZWNyZXQpIHtcbiAgICByZXR1cm4gdG90cENoZWNrV2l0aFdpbmRvdyh0b2tlbiwgc2VjcmV0LCB0aGlzLmFsbE9wdGlvbnMoKSk7XG4gIH1cbiAgY2hlY2sodG9rZW4sIHNlY3JldCkge1xuICAgIGNvbnN0IGRlbHRhID0gdGhpcy5jaGVja0RlbHRhKHRva2VuLCBzZWNyZXQpO1xuICAgIHJldHVybiB0eXBlb2YgZGVsdGEgPT09ICdudW1iZXInO1xuICB9XG4gIHZlcmlmeShvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RpbmcgYXJndW1lbnQgMCBvZiB2ZXJpZnkgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNoZWNrKG9wdHMudG9rZW4sIG9wdHMuc2VjcmV0KTtcbiAgfVxuICB0aW1lUmVtYWluaW5nKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmFsbE9wdGlvbnMoKTtcbiAgICByZXR1cm4gdG90cFRpbWVSZW1haW5pbmcob3B0aW9ucy5lcG9jaCwgb3B0aW9ucy5zdGVwKTtcbiAgfVxuICB0aW1lVXNlZCgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5hbGxPcHRpb25zKCk7XG4gICAgcmV0dXJuIHRvdHBUaW1lVXNlZChvcHRpb25zLmVwb2NoLCBvcHRpb25zLnN0ZXApO1xuICB9XG4gIGtleXVyaShhY2NvdW50TmFtZSwgaXNzdWVyLCBzZWNyZXQpIHtcbiAgICByZXR1cm4gdG90cEtleXVyaShhY2NvdW50TmFtZSwgaXNzdWVyLCBzZWNyZXQsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdXRoZW50aWNhdG9yT3B0aW9uVmFsaWRhdG9yKG9wdGlvbnMpIHtcbiAgdG90cE9wdGlvbnNWYWxpZGF0b3Iob3B0aW9ucyk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5rZXlEZWNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3Rpbmcgb3B0aW9ucy5rZXlEZWNvZGVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMua2V5RW5jb2RlciAmJiB0eXBlb2Ygb3B0aW9ucy5rZXlFbmNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3Rpbmcgb3B0aW9ucy5rZXlFbmNvZGVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGF1dGhlbnRpY2F0b3JEZWZhdWx0T3B0aW9ucygpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBhbGdvcml0aG06IGV4cG9ydHMuSGFzaEFsZ29yaXRobXMuU0hBMSxcbiAgICBjcmVhdGVEaWdlc3Q6IGNyZWF0ZURpZ2VzdFBsYWNlaG9sZGVyLFxuICAgIGNyZWF0ZUhtYWNLZXk6IHRvdHBDcmVhdGVIbWFjS2V5LFxuICAgIGRpZ2l0czogNixcbiAgICBlbmNvZGluZzogZXhwb3J0cy5LZXlFbmNvZGluZ3MuSEVYLFxuICAgIGVwb2NoOiBEYXRlLm5vdygpLFxuICAgIHN0ZXA6IDMwLFxuICAgIHdpbmRvdzogMFxuICB9O1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGF1dGhlbnRpY2F0b3JPcHRpb25zKG9wdCkge1xuICBjb25zdCBvcHRpb25zID0geyAuLi5hdXRoZW50aWNhdG9yRGVmYXVsdE9wdGlvbnMoKSxcbiAgICAuLi5vcHRcbiAgfTtcbiAgYXV0aGVudGljYXRvck9wdGlvblZhbGlkYXRvcihvcHRpb25zKTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBhdXRoZW50aWNhdG9yRW5jb2RlcihzZWNyZXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMua2V5RW5jb2RlcihzZWNyZXQsIG9wdGlvbnMuZW5jb2RpbmcpO1xufVxuZnVuY3Rpb24gYXV0aGVudGljYXRvckRlY29kZXIoc2VjcmV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmtleURlY29kZXIoc2VjcmV0LCBvcHRpb25zLmVuY29kaW5nKTtcbn1cbmZ1bmN0aW9uIGF1dGhlbnRpY2F0b3JHZW5lcmF0ZVNlY3JldChudW1iZXJPZkJ5dGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGtleSA9IG9wdGlvbnMuY3JlYXRlUmFuZG9tQnl0ZXMobnVtYmVyT2ZCeXRlcywgb3B0aW9ucy5lbmNvZGluZyk7XG4gIHJldHVybiBhdXRoZW50aWNhdG9yRW5jb2RlcihrZXksIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gYXV0aGVudGljYXRvclRva2VuKHNlY3JldCwgb3B0aW9ucykge1xuICByZXR1cm4gdG90cFRva2VuKGF1dGhlbnRpY2F0b3JEZWNvZGVyKHNlY3JldCwgb3B0aW9ucyksIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gYXV0aGVudGljYXRvckNoZWNrV2l0aFdpbmRvdyh0b2tlbiwgc2VjcmV0LCBvcHRpb25zKSB7XG4gIHJldHVybiB0b3RwQ2hlY2tXaXRoV2luZG93KHRva2VuLCBhdXRoZW50aWNhdG9yRGVjb2RlcihzZWNyZXQsIG9wdGlvbnMpLCBvcHRpb25zKTtcbn1cbmNsYXNzIEF1dGhlbnRpY2F0b3IgZXh0ZW5kcyBUT1RQIHtcbiAgY3JlYXRlKGRlZmF1bHRPcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0b3IoZGVmYXVsdE9wdGlvbnMpO1xuICB9XG4gIGFsbE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0b3JPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gIH1cbiAgZ2VuZXJhdGUoc2VjcmV0KSB7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0b3JUb2tlbihzZWNyZXQsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxuICBjaGVja0RlbHRhKHRva2VuLCBzZWNyZXQpIHtcbiAgICByZXR1cm4gYXV0aGVudGljYXRvckNoZWNrV2l0aFdpbmRvdyh0b2tlbiwgc2VjcmV0LCB0aGlzLmFsbE9wdGlvbnMoKSk7XG4gIH1cbiAgZW5jb2RlKHNlY3JldCkge1xuICAgIHJldHVybiBhdXRoZW50aWNhdG9yRW5jb2RlcihzZWNyZXQsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxuICBkZWNvZGUoc2VjcmV0KSB7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0b3JEZWNvZGVyKHNlY3JldCwgdGhpcy5hbGxPcHRpb25zKCkpO1xuICB9XG4gIGdlbmVyYXRlU2VjcmV0KG51bWJlck9mQnl0ZXMgPSAxMCkge1xuICAgIHJldHVybiBhdXRoZW50aWNhdG9yR2VuZXJhdGVTZWNyZXQobnVtYmVyT2ZCeXRlcywgdGhpcy5hbGxPcHRpb25zKCkpO1xuICB9XG59XG5cbmV4cG9ydHMuQXV0aGVudGljYXRvciA9IEF1dGhlbnRpY2F0b3I7XG5leHBvcnRzLkhBU0hfQUxHT1JJVEhNUyA9IEhBU0hfQUxHT1JJVEhNUztcbmV4cG9ydHMuSE9UUCA9IEhPVFA7XG5leHBvcnRzLktFWV9FTkNPRElOR1MgPSBLRVlfRU5DT0RJTkdTO1xuZXhwb3J0cy5PVFAgPSBPVFA7XG5leHBvcnRzLlNUUkFURUdZID0gU1RSQVRFR1k7XG5leHBvcnRzLlRPVFAgPSBUT1RQO1xuZXhwb3J0cy5hdXRoZW50aWNhdG9yQ2hlY2tXaXRoV2luZG93ID0gYXV0aGVudGljYXRvckNoZWNrV2l0aFdpbmRvdztcbmV4cG9ydHMuYXV0aGVudGljYXRvckRlY29kZXIgPSBhdXRoZW50aWNhdG9yRGVjb2RlcjtcbmV4cG9ydHMuYXV0aGVudGljYXRvckRlZmF1bHRPcHRpb25zID0gYXV0aGVudGljYXRvckRlZmF1bHRPcHRpb25zO1xuZXhwb3J0cy5hdXRoZW50aWNhdG9yRW5jb2RlciA9IGF1dGhlbnRpY2F0b3JFbmNvZGVyO1xuZXhwb3J0cy5hdXRoZW50aWNhdG9yR2VuZXJhdGVTZWNyZXQgPSBhdXRoZW50aWNhdG9yR2VuZXJhdGVTZWNyZXQ7XG5leHBvcnRzLmF1dGhlbnRpY2F0b3JPcHRpb25WYWxpZGF0b3IgPSBhdXRoZW50aWNhdG9yT3B0aW9uVmFsaWRhdG9yO1xuZXhwb3J0cy5hdXRoZW50aWNhdG9yT3B0aW9ucyA9IGF1dGhlbnRpY2F0b3JPcHRpb25zO1xuZXhwb3J0cy5hdXRoZW50aWNhdG9yVG9rZW4gPSBhdXRoZW50aWNhdG9yVG9rZW47XG5leHBvcnRzLmNyZWF0ZURpZ2VzdFBsYWNlaG9sZGVyID0gY3JlYXRlRGlnZXN0UGxhY2Vob2xkZXI7XG5leHBvcnRzLmhvdHBDaGVjayA9IGhvdHBDaGVjaztcbmV4cG9ydHMuaG90cENvdW50ZXIgPSBob3RwQ291bnRlcjtcbmV4cG9ydHMuaG90cENyZWF0ZUhtYWNLZXkgPSBob3RwQ3JlYXRlSG1hY0tleTtcbmV4cG9ydHMuaG90cERlZmF1bHRPcHRpb25zID0gaG90cERlZmF1bHRPcHRpb25zO1xuZXhwb3J0cy5ob3RwRGlnZXN0VG9Ub2tlbiA9IGhvdHBEaWdlc3RUb1Rva2VuO1xuZXhwb3J0cy5ob3RwS2V5dXJpID0gaG90cEtleXVyaTtcbmV4cG9ydHMuaG90cE9wdGlvbnMgPSBob3RwT3B0aW9ucztcbmV4cG9ydHMuaG90cE9wdGlvbnNWYWxpZGF0b3IgPSBob3RwT3B0aW9uc1ZhbGlkYXRvcjtcbmV4cG9ydHMuaG90cFRva2VuID0gaG90cFRva2VuO1xuZXhwb3J0cy5pc1Rva2VuVmFsaWQgPSBpc1Rva2VuVmFsaWQ7XG5leHBvcnRzLmtleXVyaSA9IGtleXVyaTtcbmV4cG9ydHMub2JqZWN0VmFsdWVzID0gb2JqZWN0VmFsdWVzO1xuZXhwb3J0cy5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuZXhwb3J0cy50b3RwQ2hlY2sgPSB0b3RwQ2hlY2s7XG5leHBvcnRzLnRvdHBDaGVja0J5RXBvY2ggPSB0b3RwQ2hlY2tCeUVwb2NoO1xuZXhwb3J0cy50b3RwQ2hlY2tXaXRoV2luZG93ID0gdG90cENoZWNrV2l0aFdpbmRvdztcbmV4cG9ydHMudG90cENvdW50ZXIgPSB0b3RwQ291bnRlcjtcbmV4cG9ydHMudG90cENyZWF0ZUhtYWNLZXkgPSB0b3RwQ3JlYXRlSG1hY0tleTtcbmV4cG9ydHMudG90cERlZmF1bHRPcHRpb25zID0gdG90cERlZmF1bHRPcHRpb25zO1xuZXhwb3J0cy50b3RwRXBvY2hBdmFpbGFibGUgPSB0b3RwRXBvY2hBdmFpbGFibGU7XG5leHBvcnRzLnRvdHBLZXl1cmkgPSB0b3RwS2V5dXJpO1xuZXhwb3J0cy50b3RwT3B0aW9ucyA9IHRvdHBPcHRpb25zO1xuZXhwb3J0cy50b3RwT3B0aW9uc1ZhbGlkYXRvciA9IHRvdHBPcHRpb25zVmFsaWRhdG9yO1xuZXhwb3J0cy50b3RwUGFkU2VjcmV0ID0gdG90cFBhZFNlY3JldDtcbmV4cG9ydHMudG90cFRpbWVSZW1haW5pbmcgPSB0b3RwVGltZVJlbWFpbmluZztcbmV4cG9ydHMudG90cFRpbWVVc2VkID0gdG90cFRpbWVVc2VkO1xuZXhwb3J0cy50b3RwVG9rZW4gPSB0b3RwVG9rZW47XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJvYmplY3RWYWx1ZXMiLCJrZXlzIiwibWFwIiwia2V5IiwiSGFzaEFsZ29yaXRobXMiLCJIQVNIX0FMR09SSVRITVMiLCJLZXlFbmNvZGluZ3MiLCJLRVlfRU5DT0RJTkdTIiwiU3RyYXRlZ3kiLCJTVFJBVEVHWSIsImNyZWF0ZURpZ2VzdFBsYWNlaG9sZGVyIiwiRXJyb3IiLCJpc1Rva2VuVmFsaWQiLCJ0ZXN0IiwicGFkU3RhcnQiLCJtYXhMZW5ndGgiLCJmaWxsU3RyaW5nIiwibGVuZ3RoIiwicGFkZGluZyIsIkFycmF5Iiwiam9pbiIsInNsaWNlIiwia2V5dXJpIiwib3B0aW9ucyIsInRtcGwiLCJ0eXBlIiwicGFyYW1zIiwiaW5kZXhPZiIsImNvdW50ZXIiLCJwdXNoIiwic3RlcCIsImRpZ2l0cyIsImFsZ29yaXRobSIsInRvVXBwZXJDYXNlIiwiaXNzdWVyIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImFjY291bnROYW1lIiwic2VjcmV0IiwiT1RQIiwiY29uc3RydWN0b3IiLCJkZWZhdWx0T3B0aW9ucyIsIl9kZWZhdWx0T3B0aW9ucyIsImZyZWV6ZSIsIl9vcHRpb25zIiwiY3JlYXRlIiwiY2xvbmUiLCJpbnN0YW5jZSIsImFsbE9wdGlvbnMiLCJyZXNldE9wdGlvbnMiLCJob3RwT3B0aW9uc1ZhbGlkYXRvciIsImNyZWF0ZURpZ2VzdCIsImNyZWF0ZUhtYWNLZXkiLCJlbmNvZGluZyIsImhvdHBDcmVhdGVIbWFjS2V5IiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwiaG90cERlZmF1bHRPcHRpb25zIiwiU0hBMSIsIkFTQ0lJIiwiaG90cE9wdGlvbnMiLCJvcHQiLCJob3RwQ291bnRlciIsImhleENvdW50ZXIiLCJob3RwRGlnZXN0VG9Ub2tlbiIsImhleERpZ2VzdCIsImRpZ2VzdCIsIm9mZnNldCIsImJpbmFyeSIsInRva2VuIiwiTWF0aCIsInBvdyIsIlN0cmluZyIsImhvdHBEaWdlc3QiLCJobWFjS2V5IiwiaG90cFRva2VuIiwiaG90cENoZWNrIiwic3lzdGVtVG9rZW4iLCJob3RwS2V5dXJpIiwiSE9UUCIsImdlbmVyYXRlIiwiY2hlY2siLCJ2ZXJpZnkiLCJvcHRzIiwicGFyc2VXaW5kb3dCb3VuZHMiLCJ3aW4iLCJhYnMiLCJpc0FycmF5IiwicGFzdCIsImZ1dHVyZSIsInRvdHBPcHRpb25zVmFsaWRhdG9yIiwid2luZG93IiwiZXBvY2giLCJ0b3RwUGFkU2VjcmV0IiwibWluTGVuZ3RoIiwiY3VycmVudExlbmd0aCIsImhleFNlY3JldCIsIm5ld1NlY3JldCIsInRvdHBDcmVhdGVIbWFjS2V5IiwiU0hBMjU2IiwiU0hBNTEyIiwidG90cERlZmF1bHRPcHRpb25zIiwiRGF0ZSIsIm5vdyIsInRvdHBPcHRpb25zIiwidG90cENvdW50ZXIiLCJmbG9vciIsInRvdHBUb2tlbiIsInRvdHBFcG9jaHNJbldpbmRvdyIsImRpcmVjdGlvbiIsImRlbHRhUGVyRXBvY2giLCJudW1PZkVwb2NoZXMiLCJyZXN1bHQiLCJpIiwiZGVsdGEiLCJ0b3RwRXBvY2hBdmFpbGFibGUiLCJib3VuZHMiLCJjdXJyZW50IiwidG90cENoZWNrIiwidG90cENoZWNrQnlFcG9jaCIsImVwb2NocyIsInBvc2l0aW9uIiwic29tZSIsImlkeCIsInRvdHBDaGVja1dpdGhXaW5kb3ciLCJiYWNrd2FyZCIsInRvdHBUaW1lVXNlZCIsInRvdHBUaW1lUmVtYWluaW5nIiwidG90cEtleXVyaSIsIlRPVFAiLCJjaGVja0RlbHRhIiwidGltZVJlbWFpbmluZyIsInRpbWVVc2VkIiwiYXV0aGVudGljYXRvck9wdGlvblZhbGlkYXRvciIsImtleURlY29kZXIiLCJrZXlFbmNvZGVyIiwiYXV0aGVudGljYXRvckRlZmF1bHRPcHRpb25zIiwiSEVYIiwiYXV0aGVudGljYXRvck9wdGlvbnMiLCJhdXRoZW50aWNhdG9yRW5jb2RlciIsImF1dGhlbnRpY2F0b3JEZWNvZGVyIiwiYXV0aGVudGljYXRvckdlbmVyYXRlU2VjcmV0IiwibnVtYmVyT2ZCeXRlcyIsImNyZWF0ZVJhbmRvbUJ5dGVzIiwiYXV0aGVudGljYXRvclRva2VuIiwiYXV0aGVudGljYXRvckNoZWNrV2l0aFdpbmRvdyIsIkF1dGhlbnRpY2F0b3IiLCJlbmNvZGUiLCJkZWNvZGUiLCJnZW5lcmF0ZVNlY3JldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@otplib/core/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@otplib/plugin-crypto/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@otplib/plugin-crypto/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @otplib/plugin-crypto\n *\n * @author Gerald Yeo <contact@fusedthought.com>\n * @version: 12.0.1\n * @license: MIT\n **/ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _interopDefault(ex) {\n    return ex && typeof ex === \"object\" && \"default\" in ex ? ex[\"default\"] : ex;\n}\nvar crypto = _interopDefault(__webpack_require__(/*! crypto */ \"crypto\"));\nconst createDigest = (algorithm, hmacKey, counter)=>{\n    const hmac = crypto.createHmac(algorithm, Buffer.from(hmacKey, \"hex\"));\n    const digest = hmac.update(Buffer.from(counter, \"hex\")).digest();\n    return digest.toString(\"hex\");\n};\nconst createRandomBytes = (size, encoding)=>{\n    return crypto.randomBytes(size).toString(encoding);\n};\nexports.createDigest = createDigest;\nexports.createRandomBytes = createRandomBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG90cGxpYi9wbHVnaW4tY3J5cHRvL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7RUFNRSxHQUNGO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELFNBQVNDLGdCQUFpQkMsRUFBRTtJQUFJLE9BQU8sTUFBUSxPQUFPQSxPQUFPLFlBQWEsYUFBYUEsS0FBTUEsRUFBRSxDQUFDLFVBQVUsR0FBR0E7QUFBSTtBQUVqSCxJQUFJQyxTQUFTRixnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBRXJDLE1BQU1DLGVBQWUsQ0FBQ0MsV0FBV0MsU0FBU0M7SUFDeEMsTUFBTUMsT0FBT04sT0FBT08sVUFBVSxDQUFDSixXQUFXSyxPQUFPQyxJQUFJLENBQUNMLFNBQVM7SUFDL0QsTUFBTU0sU0FBU0osS0FBS0ssTUFBTSxDQUFDSCxPQUFPQyxJQUFJLENBQUNKLFNBQVMsUUFBUUssTUFBTTtJQUM5RCxPQUFPQSxPQUFPRSxRQUFRLENBQUM7QUFDekI7QUFDQSxNQUFNQyxvQkFBb0IsQ0FBQ0MsTUFBTUM7SUFDL0IsT0FBT2YsT0FBT2dCLFdBQVcsQ0FBQ0YsTUFBTUYsUUFBUSxDQUFDRztBQUMzQztBQUVBbkIsb0JBQW9CLEdBQUdNO0FBQ3ZCTix5QkFBeUIsR0FBR2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9Ab3RwbGliL3BsdWdpbi1jcnlwdG8vaW5kZXguanM/OWJmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBvdHBsaWIvcGx1Z2luLWNyeXB0b1xuICpcbiAqIEBhdXRob3IgR2VyYWxkIFllbyA8Y29udGFjdEBmdXNlZHRob3VnaHQuY29tPlxuICogQHZlcnNpb246IDEyLjAuMVxuICogQGxpY2Vuc2U6IE1JVFxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIGNyeXB0byA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdjcnlwdG8nKSk7XG5cbmNvbnN0IGNyZWF0ZURpZ2VzdCA9IChhbGdvcml0aG0sIGhtYWNLZXksIGNvdW50ZXIpID0+IHtcbiAgY29uc3QgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGFsZ29yaXRobSwgQnVmZmVyLmZyb20oaG1hY0tleSwgJ2hleCcpKTtcbiAgY29uc3QgZGlnZXN0ID0gaG1hYy51cGRhdGUoQnVmZmVyLmZyb20oY291bnRlciwgJ2hleCcpKS5kaWdlc3QoKTtcbiAgcmV0dXJuIGRpZ2VzdC50b1N0cmluZygnaGV4Jyk7XG59O1xuY29uc3QgY3JlYXRlUmFuZG9tQnl0ZXMgPSAoc2l6ZSwgZW5jb2RpbmcpID0+IHtcbiAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhzaXplKS50b1N0cmluZyhlbmNvZGluZyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZURpZ2VzdCA9IGNyZWF0ZURpZ2VzdDtcbmV4cG9ydHMuY3JlYXRlUmFuZG9tQnl0ZXMgPSBjcmVhdGVSYW5kb21CeXRlcztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9pbnRlcm9wRGVmYXVsdCIsImV4IiwiY3J5cHRvIiwicmVxdWlyZSIsImNyZWF0ZURpZ2VzdCIsImFsZ29yaXRobSIsImhtYWNLZXkiLCJjb3VudGVyIiwiaG1hYyIsImNyZWF0ZUhtYWMiLCJCdWZmZXIiLCJmcm9tIiwiZGlnZXN0IiwidXBkYXRlIiwidG9TdHJpbmciLCJjcmVhdGVSYW5kb21CeXRlcyIsInNpemUiLCJlbmNvZGluZyIsInJhbmRvbUJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@otplib/plugin-crypto/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@otplib/plugin-thirty-two/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@otplib/plugin-thirty-two/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @otplib/plugin-thirty-two\n *\n * @author Gerald Yeo <contact@fusedthought.com>\n * @version: 12.0.1\n * @license: MIT\n **/ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _interopDefault(ex) {\n    return ex && typeof ex === \"object\" && \"default\" in ex ? ex[\"default\"] : ex;\n}\nvar thirtyTwo = _interopDefault(__webpack_require__(/*! thirty-two */ \"(rsc)/./node_modules/thirty-two/lib/thirty-two/index.js\"));\nconst keyDecoder = (encodedSecret, encoding)=>{\n    return thirtyTwo.decode(encodedSecret).toString(encoding);\n};\nconst keyEncoder = (secret, encoding)=>{\n    return thirtyTwo.encode(Buffer.from(secret, encoding).toString(\"ascii\")).toString().replace(/=/g, \"\");\n};\nexports.keyDecoder = keyDecoder;\nexports.keyEncoder = keyEncoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG90cGxpYi9wbHVnaW4tdGhpcnR5LXR3by9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0VBTUUsR0FDRjtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxTQUFTQyxnQkFBaUJDLEVBQUU7SUFBSSxPQUFPLE1BQVEsT0FBT0EsT0FBTyxZQUFhLGFBQWFBLEtBQU1BLEVBQUUsQ0FBQyxVQUFVLEdBQUdBO0FBQUk7QUFFakgsSUFBSUMsWUFBWUYsZ0JBQWdCRyxtQkFBT0EsQ0FBQztBQUV4QyxNQUFNQyxhQUFhLENBQUNDLGVBQWVDO0lBQ2pDLE9BQU9KLFVBQVVLLE1BQU0sQ0FBQ0YsZUFBZUcsUUFBUSxDQUFDRjtBQUNsRDtBQUNBLE1BQU1HLGFBQWEsQ0FBQ0MsUUFBUUo7SUFDMUIsT0FBT0osVUFBVVMsTUFBTSxDQUFDQyxPQUFPQyxJQUFJLENBQUNILFFBQVFKLFVBQVVFLFFBQVEsQ0FBQyxVQUFVQSxRQUFRLEdBQUdNLE9BQU8sQ0FBQyxNQUFNO0FBQ3BHO0FBRUFoQixrQkFBa0IsR0FBR007QUFDckJOLGtCQUFrQixHQUFHVyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QvLi9ub2RlX21vZHVsZXMvQG90cGxpYi9wbHVnaW4tdGhpcnR5LXR3by9pbmRleC5qcz83ODZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG90cGxpYi9wbHVnaW4tdGhpcnR5LXR3b1xuICpcbiAqIEBhdXRob3IgR2VyYWxkIFllbyA8Y29udGFjdEBmdXNlZHRob3VnaHQuY29tPlxuICogQHZlcnNpb246IDEyLjAuMVxuICogQGxpY2Vuc2U6IE1JVFxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIHRoaXJ0eVR3byA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd0aGlydHktdHdvJykpO1xuXG5jb25zdCBrZXlEZWNvZGVyID0gKGVuY29kZWRTZWNyZXQsIGVuY29kaW5nKSA9PiB7XG4gIHJldHVybiB0aGlydHlUd28uZGVjb2RlKGVuY29kZWRTZWNyZXQpLnRvU3RyaW5nKGVuY29kaW5nKTtcbn07XG5jb25zdCBrZXlFbmNvZGVyID0gKHNlY3JldCwgZW5jb2RpbmcpID0+IHtcbiAgcmV0dXJuIHRoaXJ0eVR3by5lbmNvZGUoQnVmZmVyLmZyb20oc2VjcmV0LCBlbmNvZGluZykudG9TdHJpbmcoJ2FzY2lpJykpLnRvU3RyaW5nKCkucmVwbGFjZSgvPS9nLCAnJyk7XG59O1xuXG5leHBvcnRzLmtleURlY29kZXIgPSBrZXlEZWNvZGVyO1xuZXhwb3J0cy5rZXlFbmNvZGVyID0ga2V5RW5jb2RlcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9pbnRlcm9wRGVmYXVsdCIsImV4IiwidGhpcnR5VHdvIiwicmVxdWlyZSIsImtleURlY29kZXIiLCJlbmNvZGVkU2VjcmV0IiwiZW5jb2RpbmciLCJkZWNvZGUiLCJ0b1N0cmluZyIsImtleUVuY29kZXIiLCJzZWNyZXQiLCJlbmNvZGUiLCJCdWZmZXIiLCJmcm9tIiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@otplib/plugin-thirty-two/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@otplib/preset-default/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@otplib/preset-default/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @otplib/preset-default\n *\n * @author Gerald Yeo <contact@fusedthought.com>\n * @version: 12.0.1\n * @license: MIT\n **/ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar pluginCrypto = __webpack_require__(/*! @otplib/plugin-crypto */ \"(rsc)/./node_modules/@otplib/plugin-crypto/index.js\");\nvar pluginThirtyTwo = __webpack_require__(/*! @otplib/plugin-thirty-two */ \"(rsc)/./node_modules/@otplib/plugin-thirty-two/index.js\");\nvar core = __webpack_require__(/*! @otplib/core */ \"(rsc)/./node_modules/@otplib/core/index.js\");\nconst hotp = new core.HOTP({\n    createDigest: pluginCrypto.createDigest\n});\nconst totp = new core.TOTP({\n    createDigest: pluginCrypto.createDigest\n});\nconst authenticator = new core.Authenticator({\n    createDigest: pluginCrypto.createDigest,\n    createRandomBytes: pluginCrypto.createRandomBytes,\n    keyDecoder: pluginThirtyTwo.keyDecoder,\n    keyEncoder: pluginThirtyTwo.keyEncoder\n});\nexports.authenticator = authenticator;\nexports.hotp = hotp;\nexports.totp = totp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG90cGxpYi9wcmVzZXQtZGVmYXVsdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0VBTUUsR0FDRjtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxlQUFlQyxtQkFBT0EsQ0FBQztBQUMzQixJQUFJQyxrQkFBa0JELG1CQUFPQSxDQUFDO0FBQzlCLElBQUlFLE9BQU9GLG1CQUFPQSxDQUFDO0FBRW5CLE1BQU1HLE9BQU8sSUFBSUQsS0FBS0UsSUFBSSxDQUFDO0lBQ3pCQyxjQUFjTixhQUFhTSxZQUFZO0FBQ3pDO0FBQ0EsTUFBTUMsT0FBTyxJQUFJSixLQUFLSyxJQUFJLENBQUM7SUFDekJGLGNBQWNOLGFBQWFNLFlBQVk7QUFDekM7QUFDQSxNQUFNRyxnQkFBZ0IsSUFBSU4sS0FBS08sYUFBYSxDQUFDO0lBQzNDSixjQUFjTixhQUFhTSxZQUFZO0lBQ3ZDSyxtQkFBbUJYLGFBQWFXLGlCQUFpQjtJQUNqREMsWUFBWVYsZ0JBQWdCVSxVQUFVO0lBQ3RDQyxZQUFZWCxnQkFBZ0JXLFVBQVU7QUFDeEM7QUFFQWYscUJBQXFCLEdBQUdXO0FBQ3hCWCxZQUFZLEdBQUdNO0FBQ2ZOLFlBQVksR0FBR1MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BvdHBsaWIvcHJlc2V0LWRlZmF1bHQvaW5kZXguanM/NTA2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBvdHBsaWIvcHJlc2V0LWRlZmF1bHRcbiAqXG4gKiBAYXV0aG9yIEdlcmFsZCBZZW8gPGNvbnRhY3RAZnVzZWR0aG91Z2h0LmNvbT5cbiAqIEB2ZXJzaW9uOiAxMi4wLjFcbiAqIEBsaWNlbnNlOiBNSVRcbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHBsdWdpbkNyeXB0byA9IHJlcXVpcmUoJ0BvdHBsaWIvcGx1Z2luLWNyeXB0bycpO1xudmFyIHBsdWdpblRoaXJ0eVR3byA9IHJlcXVpcmUoJ0BvdHBsaWIvcGx1Z2luLXRoaXJ0eS10d28nKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnQG90cGxpYi9jb3JlJyk7XG5cbmNvbnN0IGhvdHAgPSBuZXcgY29yZS5IT1RQKHtcbiAgY3JlYXRlRGlnZXN0OiBwbHVnaW5DcnlwdG8uY3JlYXRlRGlnZXN0XG59KTtcbmNvbnN0IHRvdHAgPSBuZXcgY29yZS5UT1RQKHtcbiAgY3JlYXRlRGlnZXN0OiBwbHVnaW5DcnlwdG8uY3JlYXRlRGlnZXN0XG59KTtcbmNvbnN0IGF1dGhlbnRpY2F0b3IgPSBuZXcgY29yZS5BdXRoZW50aWNhdG9yKHtcbiAgY3JlYXRlRGlnZXN0OiBwbHVnaW5DcnlwdG8uY3JlYXRlRGlnZXN0LFxuICBjcmVhdGVSYW5kb21CeXRlczogcGx1Z2luQ3J5cHRvLmNyZWF0ZVJhbmRvbUJ5dGVzLFxuICBrZXlEZWNvZGVyOiBwbHVnaW5UaGlydHlUd28ua2V5RGVjb2RlcixcbiAga2V5RW5jb2RlcjogcGx1Z2luVGhpcnR5VHdvLmtleUVuY29kZXJcbn0pO1xuXG5leHBvcnRzLmF1dGhlbnRpY2F0b3IgPSBhdXRoZW50aWNhdG9yO1xuZXhwb3J0cy5ob3RwID0gaG90cDtcbmV4cG9ydHMudG90cCA9IHRvdHA7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwbHVnaW5DcnlwdG8iLCJyZXF1aXJlIiwicGx1Z2luVGhpcnR5VHdvIiwiY29yZSIsImhvdHAiLCJIT1RQIiwiY3JlYXRlRGlnZXN0IiwidG90cCIsIlRPVFAiLCJhdXRoZW50aWNhdG9yIiwiQXV0aGVudGljYXRvciIsImNyZWF0ZVJhbmRvbUJ5dGVzIiwia2V5RGVjb2RlciIsImtleUVuY29kZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@otplib/preset-default/index.js\n");

/***/ })

};
;